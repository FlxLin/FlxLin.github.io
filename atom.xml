<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Linn</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.flxlin.github.io/"/>
  <updated>2020-02-24T10:16:49.275Z</updated>
  <id>https://www.flxlin.github.io/</id>
  
  <author>
    <name>Linn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>消息队列-RabbitMQ</title>
    <link href="https://www.flxlin.github.io/2020/02/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-rabbitemq/"/>
    <id>https://www.flxlin.github.io/2020/02/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-rabbitemq/</id>
    <published>2020-02-24T10:04:30.000Z</published>
    <updated>2020-02-24T10:16:49.275Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h2&gt;&lt;p&gt;MQ全称为Message Queue，即消息队列， RabbitMQ是由erlang语言开发，基于AMQP（Advanced MessageQueue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发中消息队列通常有如下应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务异步处理&lt;br&gt;将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。&lt;/li&gt;
&lt;li&gt;应用程序解耦合&lt;br&gt;MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="RabbitMQ" scheme="https://www.flxlin.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>页面静态化实例</title>
    <link href="https://www.flxlin.github.io/2020/02/23/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.flxlin.github.io/2020/02/23/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-02-23T13:49:33.000Z</published>
    <updated>2020-02-24T00:10:23.145Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RestTemplate&quot;&gt;&lt;a href=&quot;#RestTemplate&quot; class=&quot;headerlink&quot; title=&quot;RestTemplate&quot;&gt;&lt;/a&gt;RestTemplate&lt;/h2&gt;&lt;p&gt;&lt;em&gt;SpringMVC提供 RestTemplate请求http接口，RestTemplate的底层可以使用第三方的http客户端工具实现http 的请求，常用的http客户端工具有Apache HttpClient、OkHttpClient等&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置依赖&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;com.squareup.okhttp3&amp;lt;&amp;#x2F;groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;okhttp&amp;lt;&amp;#x2F;artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;#x2F;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Freemarker" scheme="https://www.flxlin.github.io/tags/Freemarker/"/>
    
  </entry>
  
  <entry>
    <title>自定义异常及捕获</title>
    <link href="https://www.flxlin.github.io/2020/02/21/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%8F%8A%E6%8D%95%E8%8E%B7/"/>
    <id>https://www.flxlin.github.io/2020/02/21/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%8F%8A%E6%8D%95%E8%8E%B7/</id>
    <published>2020-02-21T12:22:33.000Z</published>
    <updated>2020-02-21T12:30:25.608Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;系统对异常的处理使用统一的异常处理流程：&lt;/strong&gt;&lt;br&gt;1、自定义异常类型。&lt;br&gt;2、自定义错误代码及错误信息。&lt;br&gt;3、对于可预知的异常由程序员在代码中主动抛出，由SpringMVC统一捕获。&lt;br&gt;可预知异常是程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，通常异常信息比较&lt;br&gt;齐全，程序员在抛出时会指定错误代码及错误信息，获取异常信息也比较方便。&lt;br&gt;4、对于不可预知的异常（运行时异常）由SpringMVC统一捕获Exception类型的异常。&lt;br&gt;不可预知异常通常是由于系统出现bug、或一些不要抗拒的错误（比如网络中断、服务器宕机等），异常类型为&lt;br&gt;RuntimeException类型（运行时异常）。&lt;br&gt;5、可预知的异常及不可预知的运行时异常最终会采用统一的信息格式（错误代码+错误信息）来表示，最终也会随&lt;br&gt;请求响应给客户端。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://www.flxlin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>页面静态化</title>
    <link href="https://www.flxlin.github.io/2020/02/21/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96/"/>
    <id>https://www.flxlin.github.io/2020/02/21/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96/</id>
    <published>2020-02-21T11:33:45.000Z</published>
    <updated>2020-02-24T10:18:10.959Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;页面静态化&quot;&gt;&lt;a href=&quot;#页面静态化&quot; class=&quot;headerlink&quot; title=&quot;页面静态化&quot;&gt;&lt;/a&gt;页面静态化&lt;/h2&gt;&lt;p&gt;&lt;em&gt;模板+数据模型=输出，页面静态化需要准备数据模型和模板，先知道数据模型的结构才可以编写模板，因为在模板中要引用数据模型中的数据&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何对页面进行静态化&lt;br&gt;一个页面等于模板加数据，在添加页面的时候我们选择了页面的模板。页面静态化就是将页面模板和数据通过技术手段将二者合二为一，生成一个html网页文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Freemarker&quot;&gt;&lt;a href=&quot;#Freemarker&quot; class=&quot;headerlink&quot; title=&quot;Freemarker&quot;&gt;&lt;/a&gt;Freemarker&lt;/h2&gt;&lt;p&gt;FreeMarker是一个基于Java的模板引擎，最初专注于使用MVC软件架构生成动态网页。freemarker并不关心数据的来源，只是根据模板的内容，将数据模型在模板中显示并输出文件（通常为html，也可以生成其它格式的文本文件）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Freemarker" scheme="https://www.flxlin.github.io/tags/Freemarker/"/>
    
  </entry>
  
  <entry>
    <title>Vue几种传参方式</title>
    <link href="https://www.flxlin.github.io/2020/02/20/Vue%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/"/>
    <id>https://www.flxlin.github.io/2020/02/20/Vue%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/</id>
    <published>2020-02-20T10:16:40.000Z</published>
    <updated>2020-02-21T11:55:30.663Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue常见的传参方式&quot;&gt;&lt;a href=&quot;#Vue常见的传参方式&quot; class=&quot;headerlink&quot; title=&quot;Vue常见的传参方式&quot;&gt;&lt;/a&gt;Vue常见的传参方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;URL传参&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//路由定义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;attr&quot;&gt;path&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;/cms/page/edit/:pageId&#39;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;修改页面&#39;&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;component&lt;/span&gt;: Page_edit,&lt;span class=&quot;attr&quot;&gt;hidden&lt;/span&gt;:&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//：+ 参数名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.$router.push(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          path:&lt;span class=&quot;string&quot;&gt;&#39;/cms/page/edit/&#39;&lt;/span&gt; + pageId&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://www.flxlin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题</title>
    <link href="https://www.flxlin.github.io/2020/02/18/proxyTable%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://www.flxlin.github.io/2020/02/18/proxyTable%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-18T05:37:06.000Z</published>
    <updated>2020-02-18T06:46:25.690Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;跨域问题报错&quot;&gt;&lt;a href=&quot;#跨域问题报错&quot; class=&quot;headerlink&quot; title=&quot;跨域问题报错&quot;&gt;&lt;/a&gt;跨域问题报错&lt;/h2&gt;&lt;p&gt;&lt;em&gt;No ‘Access-Control-Allow-Origin’ header is present on the requested resource.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原因：浏览器的同源策略不允许跨域访问，所谓同源策略是指协议、域名、端口相同。&lt;/li&gt;
&lt;li&gt;解决：采用proxyTable解决。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;proxyTable是什么？&quot;&gt;&lt;a href=&quot;#proxyTable是什么？&quot; class=&quot;headerlink&quot; title=&quot;proxyTable是什么？&quot;&gt;&lt;/a&gt;proxyTable是什么？&lt;/h2&gt;&lt;p&gt;&lt;em&gt;vue-cli提供的解决vue开发环境下跨域问题的方法，proxyTable的底层使用了http-proxymiddleware（&lt;a href=&quot;https://github.com/chimurai/http-proxy-middleware）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/chimurai/http-proxy-middleware）&lt;/a&gt; ，它是http代理中间件，它依赖node.js， 基本原理是用服务端代理解决浏览器跨域：&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://www.flxlin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack-dev-server</title>
    <link href="https://www.flxlin.github.io/2020/02/16/webpack-dev-server/"/>
    <id>https://www.flxlin.github.io/2020/02/16/webpack-dev-server/</id>
    <published>2020-02-16T11:51:29.000Z</published>
    <updated>2020-02-16T12:14:28.668Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;webpack-dev-server&quot;&gt;&lt;a href=&quot;#webpack-dev-server&quot; class=&quot;headerlink&quot; title=&quot;webpack-dev-server&quot;&gt;&lt;/a&gt;webpack-dev-server&lt;/h2&gt;&lt;p&gt;&lt;em&gt;webpack-dev-server开发服务器，它的功能可以实现热加载 并且自动刷新浏览器&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;npm install webpack@3.6.0 webpack-dev-server@2.9.1 html-webpack-plugin@2.30.1 --save-dev &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="Webpack" scheme="https://www.flxlin.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack实践</title>
    <link href="https://www.flxlin.github.io/2020/02/16/webpack%E5%AE%9E%E8%B7%B5/"/>
    <id>https://www.flxlin.github.io/2020/02/16/webpack%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-02-16T07:05:18.000Z</published>
    <updated>2020-02-16T07:27:00.597Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Webpack介绍&quot;&gt;&lt;a href=&quot;#Webpack介绍&quot; class=&quot;headerlink&quot; title=&quot;Webpack介绍&quot;&gt;&lt;/a&gt;Webpack介绍&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Webpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模块化开发&lt;br&gt;程序员在开发时可以分模块创建不同的js、 css等小文件方便开发，最后使用webpack将这些小文件打包成一个文 件，减少了http的请求次数。 webpack可以实现按需打包，为了避免出现打包文件过大可以打包成多个文件。&lt;/li&gt;
&lt;li&gt;编译typescript、ES6等高级js语法&lt;br&gt;随着前端技术的强大，开发中可以使用javascript的很多高级版本，比如：typescript、ES6等，方便开发， webpack可以将打包文件转换成浏览器可识别的js语法。 &lt;/li&gt;
&lt;li&gt;CSS预编译&lt;br&gt;webpack允许在开发中使用Sass 和 Less等原生CSS的扩展技术，通过sass-loader、less-loader将Sass 和 Less的 语法编译成浏览器可识别的css语法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Wehpack" scheme="https://www.flxlin.github.io/tags/Wehpack/"/>
    
  </entry>
  
  <entry>
    <title>vue.js入门</title>
    <link href="https://www.flxlin.github.io/2020/02/16/vue-js%E5%85%A5%E9%97%A8/"/>
    <id>https://www.flxlin.github.io/2020/02/16/vue-js%E5%85%A5%E9%97%A8/</id>
    <published>2020-02-16T07:04:56.000Z</published>
    <updated>2020-02-16T07:18:25.563Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue是什么？&quot;&gt;&lt;a href=&quot;#Vue是什么？&quot; class=&quot;headerlink&quot; title=&quot;Vue是什么？&quot;&gt;&lt;/a&gt;Vue是什么？&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计 为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一 方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 渐进式框架：Progressive，说明vue.js的轻量，是指一个前端项目可以使用vue.js一两个特性也可以整个项目都用 vue.js。&lt;br&gt;自底向上逐层应用：作为渐进式框架要实现的目标就是方便项目增量开发。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://www.flxlin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Python配合ffmpeg爬取视频</title>
    <link href="https://www.flxlin.github.io/2020/02/09/Python%E9%85%8D%E5%90%88ffmpeg%E7%88%AC%E5%8F%96%E8%A7%86%E9%A2%91/"/>
    <id>https://www.flxlin.github.io/2020/02/09/Python%E9%85%8D%E5%90%88ffmpeg%E7%88%AC%E5%8F%96%E8%A7%86%E9%A2%91/</id>
    <published>2020-02-09T11:39:20.000Z</published>
    <updated>2020-02-16T07:32:49.309Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;主要采用python配合ffmpeg对一些视频进行爬取，需要配置ffmpeg才能运行。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;Python代码&quot;&gt;&lt;a href=&quot;#Python代码&quot; class=&quot;headerlink&quot; title=&quot;Python代码&quot;&gt;&lt;/a&gt;Python代码&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="https://www.flxlin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>有道翻译--爬虫</title>
    <link href="https://www.flxlin.github.io/2020/02/05/%E6%9C%89%E9%81%93%E7%BF%BB%E8%AF%91-%E7%88%AC%E8%99%AB/"/>
    <id>https://www.flxlin.github.io/2020/02/05/%E6%9C%89%E9%81%93%E7%BF%BB%E8%AF%91-%E7%88%AC%E8%99%AB/</id>
    <published>2020-02-05T02:08:32.000Z</published>
    <updated>2020-02-16T07:08:32.115Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;使用requests, json实现的的一个简单的爬虫，爬取了有道翻译，可实现自动翻译的功能。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Pyhton" scheme="https://www.flxlin.github.io/tags/Pyhton/"/>
    
  </entry>
  
  <entry>
    <title>Python实现简单的通信协议</title>
    <link href="https://www.flxlin.github.io/2020/02/01/Python%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <id>https://www.flxlin.github.io/2020/02/01/Python%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-02-01T02:42:51.000Z</published>
    <updated>2020-02-16T12:04:00.685Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;使用socket实现的的一个简单的自定义协议，模拟实现了QQ的小部分功能。其中涉及到json的使用，以及多线程的创建等等。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;主要功能&quot;&gt;&lt;a href=&quot;#主要功能&quot; class=&quot;headerlink&quot; title=&quot;主要功能&quot;&gt;&lt;/a&gt;主要功能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;多用户连接&lt;/li&gt;
&lt;li&gt;即时通讯&lt;/li&gt;
&lt;li&gt;登陆，退出&lt;/li&gt;
&lt;li&gt;历史消息&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="https://www.flxlin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python关于socket编程</title>
    <link href="https://www.flxlin.github.io/2020/01/29/Python%E5%85%B3%E4%BA%8Esocket%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.flxlin.github.io/2020/01/29/Python%E5%85%B3%E4%BA%8Esocket%E7%BC%96%E7%A8%8B/</id>
    <published>2020-01-29T02:45:32.000Z</published>
    <updated>2020-02-16T07:07:27.608Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。采用python实现了简单了服务器与客户端的交互。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; class=&quot;headerlink&quot; title=&quot;服务端&quot;&gt;&lt;/a&gt;服务端&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="https://www.flxlin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>cocos2d-creator</title>
    <link href="https://www.flxlin.github.io/2020/01/21/cocos2d-creator/"/>
    <id>https://www.flxlin.github.io/2020/01/21/cocos2d-creator/</id>
    <published>2020-01-21T06:24:16.000Z</published>
    <updated>2020-02-16T07:07:25.759Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;这是我近期学习cocos2d_creator的收获，主要是关于js脚本编写。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="js" scheme="https://www.flxlin.github.io/tags/js/"/>
    
  </entry>
  
</feed>
